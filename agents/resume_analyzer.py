import json
import requests
from utils import strip_thinking_tags, parse_json_safely


class ResumeAnalyzerAgent:
    PROMPT = """
        Ты HR-эксперт. Тебе даётся текст РЕЗЮМЕ (может быть пустым) и СПИСОК ВАКАНСИЙ с требованиями.

        ЭТАП 1 — ЭТО РЕЗЮМЕ?
        - Сначала определи, похож ли текст на резюме (CV) кандидата.
        Если НЕТ (например, новостная статья, тестовое задание, диплом, пустой файл):
            • Верни JSON строго по схеме (ниже) со "Статус"."Это резюме" = false,
            • "Кандидат" — по возможности извлеки данные, иначе null/не указан,
            • "Анализ"."Оценка требований" = {}, "Средняя оценка" = 0, "Вопросы" = [],
            • В "Общий вывод" кратко напиши, почему это не резюме (или что резюме отсутствует).

        ЭТАП 2 — ВЫБОР ВАКАНСИИ
        - Если это резюме (CV), проверь соответствие КАК МИНИМУМ одной вакансии из списка.
        - Если ни одной подходящей вакансии нет:
            • Верни JSON по схеме: "Это резюме" = true, но
            • "Оценка требований" = {}, "Средняя оценка" = 0, "Вопросы" = [],
            • В "Общий вывод" явно напиши, что ни одной подходящей вакансии не найдено.
        - Если есть совпадения:
            • Выбери ОДНУ ЛУЧШУЮ вакансию и анализируй ТОЛЬКО её требования.
            • Явно укажи поле "Выбранная вакансия" с точным названием (строго как в списке), и в "Общий вывод" кратко обоснуй выбор.

        ДОПОЛНИТЕЛЬНО — ПОДСВЕТКИ ВНУТРИ «ОЦЕНКА ТРЕБОВАНИЙ» (ПО СТРОКАМ)
        - Разбивай резюме на строки (по символу перевода строки). Подсветки привязывай к конкретным требованиям в разделе «Оценка требований».
        - Внутри каждого объекта требования добавляй массив «подсветка»: список строк или диапазонов строк, где резюме подтверждает/обосновывает выставленный балл и комментарий ИМЕННО по ЭТОМУ требованию.
        - ВАЖНО: элементы «подсветка» содержат ТОЛЬКО координаты строк/фрагментов (без полей «тон» и «комментарий»). Комментарий берётся из поля "комментарий" этого требования, а цвет UI определяется по значению "балл" автоматически (<30 — красный, 30–60 — жёлтый, >60 — зелёный).
        - Допустимые форматы элемента «подсветка» (любой из):
          1) {"line": 12}
          2) {"line": "3-6"}
          3) {"line_from": 2, "line_to": 5}
          4) {"line": 10, "start": 5, "end": 20}
          5) {"line": 7, "цитата": "подстрока"}
        - В пределах одной строки подсветки не должны перекрываться.
        - ОБЯЗАТЕЛЬНО: для КАЖДОГО требования, которому ты выставляешь «балл», добавь ХОТЯ БЫ ОДНУ подсветку.
          • Если балл высокий — подсветь строк(и), подтверждающие совпадение (ключевые навыки/опыт/сертификаты и т.п.).
          • Если балл низкий из‑за НЕСООТВЕТСТВИЯ (переквалификация/недостаток опыта/не тот уровень образования) — подсветь строк(и) с фактическими данными (напр., «22 года опыта», «кандидат наук»), которые обосновывают низкий балл.
          • Если балл снижен из‑за ОТСУТСТВИЯ явного упоминания — подсветь наиболее релевантную строку/раздел (например, «Навыки», «Опыт», «Обо мне»), куда обычно попадает такая информация, чтобы указать, где проверялось.

        СИНХРОНИЗАЦИЯ НУМЕРАЦИИ СТРОК
        - Ниже я передам РЕЗЮМЕ, в котором каждая строка будет ПРЕДВАРИТЕЛЬНО ПРОНУМЕРОВАНА, например: "1: ...", "2: ..." и т.д.
        - Используй ИМЕННО ЭТИ номера (1-базная нумерация) в полях «подсветка» (line/line_from/line_to/line="a-b").
        - Если указываешь start/end — это индексы относительно СОДЕРЖИМОГО СТРОКИ БЕЗ префикса "N: ", то есть считая только реальный текст резюме.

        СТРОГО ВЕРНИ ТОЛЬКО JSON (БЕЗ КОД-БЛОКОВ) ПО СХЕМЕ:
        {
          "Статус": {
            "Это резюме": true|false,
            "Причина": "краткое пояснение (почему да/нет)"
          },
          "Кандидат": {
            "Возраст": 0 или null,
            "Пол": "мужской|женский|не указан",
            "Адрес": "строка или null (только город)"
          },
          "Анализ": {
            "Выбранная вакансия": "строка или null",
            "Оценка требований": {
              "Текст требования": {
                "балл": 0-100,
                "комментарий": "текст",
                "подсветка": [ {"line": 1}, {"line": "2-3"} ]
              }
            },
            "Средняя оценка": 0-100,
            "Общий вывод": "текст"
          },
          "Вопросы": ["Вопрос 1", "Вопрос 2", "Вопрос 3", "Вопрос 4"]
        }

        ПРАВИЛА:
        - В "Оценка требований" ключами должны быть полные тексты требований (без переименований).
        - Если "Это резюме" = false: "Оценка требований" = {}, "Средняя оценка" = 0, "Вопросы" = [].
        - Если нет подходящей вакансии: "Оценка требований" = {}, "Средняя оценка" = 0, "Вопросы" = [] и явное пояснение в "Общий вывод".
        - Если данных не хватает — ставь null или "не указан" (для "Пол").
        """

    def __init__(self, api_base_url: str, model_name: str):
        self.api_base_url = api_base_url.rstrip("/")
        self.model_name = model_name

    def _call_llm(self, prompt: str) -> str:
        payload = {
            "model": self.model_name,
            "messages": [{"role": "user", "content": prompt}],
        }
        url = f"{self.api_base_url}/chat/completions"
        resp = requests.post(url, json=payload, timeout=90)
        resp.raise_for_status()
        raw_answer = resp.json()["choices"][0]["message"]["content"]
        return strip_thinking_tags(raw_answer)

    def analyze_and_questions(
        self, resume_text: str | None, job_sets: list[dict]
    ) -> dict:
        """
        job_sets: [{"id": 1, "name": "...", "requirements": [str, ...]}, ...]
        """
        # 1) Пустое/отсутствующее резюме — возвращаем валидный JSON без вызова LLM
        if not resume_text or not str(resume_text).strip():
            return {
                "Статус": {
                    "Это резюме": False,
                    "Причина": "файл отсутствует или пустой",
                },
                "Кандидат": {
                    "Возраст": None,
                    "Пол": "не указан",
                    "Адрес": None,
                },
                "Анализ": {
                    "Оценка требований": {},
                    "Средняя оценка": 0,
                    "Общий вывод": "Резюме не предоставлено или текст пустой",
                },
                "Вопросы": [],
            }

        # 2) Нет вакансий — это ошибка конфигурации
        if not job_sets:
            raise ValueError("❌ Нет требований вакансий (job_sets пуст)")

        # 3) Готовим компактный список вакансий для промпта
        safe_job_sets = []
        for v in job_sets:
            reqs = [
                str(r).strip() for r in (v.get("requirements") or []) if str(r).strip()
            ]
            if not reqs:
                continue
            safe_job_sets.append(
                {
                    "id": v.get("id"),
                    "name": v.get("name"),
                    "requirements": reqs,
                }
            )
        if not safe_job_sets:
            raise ValueError("❌ Все наборы требований пусты")

        # Важно: резюме ниже будет передано с нумерацией строк для синхронизации.
        lines = (resume_text or "").splitlines()
        numbered_resume = "\n".join(f"{i+1}: {line}" for i, line in enumerate(lines))

        prompt = f"""
{self.PROMPT}

Список вакансий (анализируй и выбирай максимум одну):
{json.dumps(safe_job_sets, ensure_ascii=False, indent=2)}

Резюме кандидата (каждая строка пронумерована, используй эти номера в «подсветка»):
{numbered_resume}
        """.strip()

        clean_answer = self._call_llm(prompt)

        try:
            return parse_json_safely(clean_answer)
        except Exception:
            return {"raw_response": clean_answer}